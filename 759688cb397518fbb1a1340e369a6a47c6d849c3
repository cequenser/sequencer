{
  "comments": [
    {
      "robotId": "clang-format",
      "robotRunId": "http://source.kaidimensional.de:8080/job/psv/job/clang-format/562/",
      "fixSuggestions": [],
      "key": {
        "uuid": "462ee98b_bb31b73f",
        "filename": "include/sequencer/audio/fft.hpp",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1016797
      },
      "writtenOn": "2019-09-02T20:12:38Z",
      "side": 1,
      "message": "namespace sequencer::audio\n {\n     template \u003c class T \u003e\n-    constexpr T minus_two_pi \u003d T( -2*M_PI );\n+    constexpr T minus_two_pi \u003d T( -2 * M_PI );\n \n     template \u003c class T \u003e\n     class vector_view\n             return std::vector{x[ 0 ]};\n         }\n \n-        auto y \u003d radix2( vector_view{ \u0026x, 0 } );\n-        auto z \u003d radix2( vector_view{ \u0026x, 1 } );\n+        auto y \u003d radix2( vector_view{\u0026x, 0} );\n+        auto z \u003d radix2( vector_view{\u0026x, 1} );\n \n         y.resize( N );\n         using namespace std::complex_literals;\n         for ( typename Container::size_type k \u003d 0; k \u003c N / 2; ++k )\n         {\n             const auto a \u003d T( k ) / N;\n-            const auto dy \u003d std::exp( minus_two_pi\u003cT\u003e * 1i * a ) * z[ k ];\n+            const auto dy \u003d std::exp( minus_two_pi\u003c T \u003e * 1i * a ) * z[ k ];\n             y[ N / 2 + k ] \u003d y[ k ] - dy;\n             y[ k ] +\u003d dy;\n         }\n         return y;\n     }\n \n-    template \u003cclass Container\u003e\n-    auto inverse_radix2(Container x)\n+    template \u003c class Container \u003e\n+    auto inverse_radix2( Container x )\n     {\n         using T \u003d typename Container::value_type::value_type;\n \n-        for(auto\u0026 v : x)\n+        for ( auto\u0026 v : x )\n         {\n-            v \u003d conj(v);\n+            v \u003d conj( v );\n         }\n \n-        auto y \u003d radix2(x);\n-        for(auto\u0026 v : y)\n+        auto y \u003d radix2( x );\n+        for ( auto\u0026 v : y )\n         {\n-            v \u003d conj(v)/T(y.size());\n+            v \u003d conj( v ) / T( y.size() );\n         }\n \n         return y;\n     }\n \n-    template \u003cclass T\u003e\n+    template \u003c class T \u003e\n     std::vector\u003c std::complex\u003c T \u003e \u003e to_complex_signal( const std::vector\u003c T \u003e\u0026 v )\n     {\n         std::vector\u003c std::complex\u003c T \u003e \u003e signal( v.size() / 2 );\n-        std::memcpy(signal.data(), v.data(), v.size()*sizeof (T));\n+        std::memcpy( signal.data(), v.data(), v.size() * sizeof( T ) );\n         return signal;\n     }\n \n-    template \u003cclass T\u003e\n-    std::vector\u003c std::complex\u003cT\u003e \u003e fft( const std::vector\u003c T \u003e\u0026 x )\n+    template \u003c class T \u003e\n+    std::vector\u003c std::complex\u003c T \u003e \u003e fft( const std::vector\u003c T \u003e\u0026 x )\n     {\n         using namespace std::complex_literals;\n         assert( x.size() % 2 \u003d\u003d 0 );\n         const auto half_result \u003d radix2( to_complex_signal( x ) );\n \n-        std::vector\u003c std::complex\u003cT\u003e \u003e result( half_result.size() );\n+        std::vector\u003c std::complex\u003c T \u003e \u003e result( half_result.size() );\n         const auto M \u003d result.size();\n         const auto scale \u003d T{0.5};\n         for ( typename std::vector\u003c T \u003e::size_type k \u003d 0; k \u003c M; ++k )\n         {\n-            const auto M_k \u003d (k\u003d\u003d0) ? 0 : M-k;\n+            const auto M_k \u003d ( k \u003d\u003d 0 ) ? 0 : M - k;\n             const auto z \u003d conj( half_result[ M_k ] );\n-            const auto a \u003d T(k)/x.size();\n-            result[ k ] \u003d scale * ( ( half_result[ k ] + z ) -\n-                                         1i * ( half_result[ k ] - z ) *\n-                                         std::exp( minus_two_pi\u003cT\u003e * 1i * a ) );\n+            const auto a \u003d T( k ) / x.size();\n+            result[ k ] \u003d\n+                scale * ( ( half_result[ k ] + z ) -\n+                          1i * ( half_result[ k ] - z ) * std::exp( minus_two_pi\u003c T \u003e * 1i * a ) );\n         }\n \n         return result;\n     }\n \n-    template \u003cclass T\u003e\n+    template \u003c class T \u003e\n     std::vector\u003c T \u003e fft_abs_scaled( const std::vector\u003c T \u003e\u0026 x )\n     {\n         using namespace std::complex_literals;\n \n         std::vector\u003c T \u003e result( half_result.size() );\n         const auto M \u003d result.size();\n-        const auto scale \u003d T{0.5/result.size()};\n+        const auto scale \u003d T{0.5 / result.size()};\n         for ( typename std::vector\u003c T \u003e::size_type k \u003d 0; k \u003c M; ++k )\n         {\n-            const auto M_k \u003d (k\u003d\u003d0) ? 0 : M-k;\n+            const auto M_k \u003d ( k \u003d\u003d 0 ) ? 0 : M - k;\n             const auto z \u003d conj( half_result[ M_k ] );\n-            const auto a \u003d T(k)/x.size();\n+            const auto a \u003d T( k ) / x.size();\n             result[ k ] \u003d scale * abs( ( half_result[ k ] + z ) -\n-                                         1i * ( half_result[ k ] - z ) *\n-                                         std::exp( minus_two_pi\u003cT\u003e * 1i * a ) );\n+                                       1i * ( half_result[ k ] - z ) *\n+                                           std::exp( minus_two_pi\u003c T \u003e * 1i * a ) );\n         }\n \n         return result;",
      "revId": "759688cb397518fbb1a1340e369a6a47c6d849c3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "robotId": "clang-tidy",
      "robotRunId": "http://source.kaidimensional.de:8080/job/psv/job/clang-tidy/628/",
      "fixSuggestions": [],
      "key": {
        "uuid": "96b4903b_93fe1521",
        "filename": "include/sequencer/audio/fft.hpp",
        "patchSetId": 1
      },
      "lineNbr": 56,
      "author": {
        "id": 1016797
      },
      "writtenOn": "2019-09-02T20:11:26Z",
      "side": 1,
      "message": "invalid case style for type alias \u0027CT\u0027 [readability-identifier-naming,-warnings-as-errors]\n        using CT \u003d typename Container::value_type;\n              ^~\n              ct",
      "revId": "759688cb397518fbb1a1340e369a6a47c6d849c3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "robotId": "clang-tidy",
      "robotRunId": "http://source.kaidimensional.de:8080/job/psv/job/clang-tidy/628/",
      "fixSuggestions": [],
      "key": {
        "uuid": "e909eb6e_85531151",
        "filename": "include/sequencer/audio/fft.hpp",
        "patchSetId": 1
      },
      "lineNbr": 57,
      "author": {
        "id": 1016797
      },
      "writtenOn": "2019-09-02T20:11:26Z",
      "side": 1,
      "message": "invalid case style for type alias \u0027T\u0027 [readability-identifier-naming,-warnings-as-errors]\n        using T \u003d typename CT::value_type;\n              ^\n              t",
      "revId": "759688cb397518fbb1a1340e369a6a47c6d849c3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "robotId": "clang-tidy",
      "robotRunId": "http://source.kaidimensional.de:8080/job/psv/job/clang-tidy/628/",
      "fixSuggestions": [],
      "key": {
        "uuid": "a828a17f_475af1a1",
        "filename": "include/sequencer/audio/fft.hpp",
        "patchSetId": 1
      },
      "lineNbr": 58,
      "author": {
        "id": 1016797
      },
      "writtenOn": "2019-09-02T20:11:26Z",
      "side": 1,
      "message": "invalid case style for variable \u0027N\u0027 [readability-identifier-naming,-warnings-as-errors]\n        const auto N \u003d x.size();\n                   ^\n                   n",
      "revId": "759688cb397518fbb1a1340e369a6a47c6d849c3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "robotId": "clang-tidy",
      "robotRunId": "http://source.kaidimensional.de:8080/job/psv/job/clang-tidy/628/",
      "fixSuggestions": [],
      "key": {
        "uuid": "454a379b_f89540fd",
        "filename": "include/sequencer/audio/fft.hpp",
        "patchSetId": 1
      },
      "lineNbr": 83,
      "author": {
        "id": 1016797
      },
      "writtenOn": "2019-09-02T20:11:26Z",
      "side": 1,
      "message": "invalid case style for type alias \u0027T\u0027 [readability-identifier-naming,-warnings-as-errors]\n        using T \u003d typename Container::value_type::value_type;\n              ^\n              t\nSuppressed 7065 warnings (7065 in non-user code).\nUse -header-filter\u003d.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.\n8 warnings treated as errors\nSuppressed 7388 warnings (7388 in non-user code).\nUse -header-filter\u003d.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.\nSuppressed 6688 warnings (6688 in non-user code).\nUse -header-filter\u003d.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.\nSuppressed 6686 warnings (6686 in non-user code).\nUse -header-filter\u003d.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.\nSuppressed 6689 warnings (6689 in non-user code).\nUse -header-filter\u003d.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.\nSuppressed 6699 warnings (6698 in non-user code, 1 NOLINT).\nUse -header-filter\u003d.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.\nSuppressed 6739 warnings (6738 in non-user code, 1 NOLINT).\nUse -header-filter\u003d.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.\nSuppressed 7263 warnings (7263 in non-user code).\nUse -header-filter\u003d.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.\nSuppressed 6680 warnings (6680 in non-user code).\nUse -header-filter\u003d.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.\nSuppressed 3762 warnings (3762 in non-user code).\nUse -header-filter\u003d.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.\nSuppressed 11472 warnings (11472 in non-user code).\nUse -header-filter\u003d.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.\nSuppressed 6746 warnings (6746 in non-user code).\nUse -header-filter\u003d.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.\nSuppressed 4150 warnings (4150 in non-user code).\nUse -header-filter\u003d.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.\nSuppressed 3652 warnings (3652 in non-user code).\nUse -header-filter\u003d.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.\nSuppressed 4036 warnings (4036 in non-user code).\nUse -header-filter\u003d.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.\nSuppressed 6749 warnings (6749 in non-user code).\nUse -header-filter\u003d.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.",
      "revId": "759688cb397518fbb1a1340e369a6a47c6d849c3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "robotId": "clang-tidy",
      "robotRunId": "http://source.kaidimensional.de:8080/job/psv/job/clang-tidy/628/",
      "fixSuggestions": [],
      "key": {
        "uuid": "c27ec763_e3eb2f46",
        "filename": "include/sequencer/audio/fft.hpp",
        "patchSetId": 1
      },
      "lineNbr": 119,
      "author": {
        "id": 1016797
      },
      "writtenOn": "2019-09-02T20:11:26Z",
      "side": 1,
      "message": "invalid case style for variable \u0027M_k\u0027 [readability-identifier-naming,-warnings-as-errors]\n            const auto M_k \u003d (k\u003d\u003d0) ? 0 : M-k;\n                       ^~~\n                       m_k",
      "revId": "759688cb397518fbb1a1340e369a6a47c6d849c3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "robotId": "clang-tidy",
      "robotRunId": "http://source.kaidimensional.de:8080/job/psv/job/clang-tidy/628/",
      "fixSuggestions": [],
      "key": {
        "uuid": "c666e921_2fa4d434",
        "filename": "include/sequencer/audio/fft.hpp",
        "patchSetId": 1
      },
      "lineNbr": 138,
      "author": {
        "id": 1016797
      },
      "writtenOn": "2019-09-02T20:11:26Z",
      "side": 1,
      "message": "invalid case style for variable \u0027M\u0027 [readability-identifier-naming,-warnings-as-errors]\n        const auto M \u003d result.size();\n                   ^\n                   m",
      "revId": "759688cb397518fbb1a1340e369a6a47c6d849c3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "robotId": "clang-tidy",
      "robotRunId": "http://source.kaidimensional.de:8080/job/psv/job/clang-tidy/628/",
      "fixSuggestions": [],
      "key": {
        "uuid": "09ca5cc8_2f941153",
        "filename": "include/sequencer/audio/fft.hpp",
        "patchSetId": 1
      },
      "lineNbr": 142,
      "author": {
        "id": 1016797
      },
      "writtenOn": "2019-09-02T20:11:26Z",
      "side": 1,
      "message": "invalid case style for variable \u0027M_k\u0027 [readability-identifier-naming,-warnings-as-errors]\n            const auto M_k \u003d (k\u003d\u003d0) ? 0 : M-k;\n                       ^~~\n                       m_k",
      "revId": "759688cb397518fbb1a1340e369a6a47c6d849c3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    },
    {
      "robotId": "clang-format",
      "robotRunId": "http://source.kaidimensional.de:8080/job/psv/job/clang-format/562/",
      "fixSuggestions": [],
      "key": {
        "uuid": "315fc217_1ccb8011",
        "filename": "tests/sequencer/audio/fft_test.cpp",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1016797
      },
      "writtenOn": "2019-09-02T20:12:38Z",
      "side": 1,
      "message": "#include \u003ccmath\u003e\n #include \u003climits\u003e\n \n-constexpr auto signal_size \u003d 32*8;\n+constexpr auto signal_size \u003d 32 * 8;\n \n-SCENARIO(\"sine waves of 50 and 80 Hz\", \"fft\")\n+SCENARIO( \"sine waves of 50 and 80 Hz\", \"fft\" )\n {\n     using namespace sequencer::audio;\n \n-    GIVEN(\"overlapping sine waves of 50 and 80 Hz\")\n+    GIVEN( \"overlapping sine waves of 50 and 80 Hz\" )\n     {\n         double counter \u003d 0;\n-        auto signal \u003d std::vector\u003cdouble\u003e(signal_size);\n-        std::generate(begin(signal), end(signal), [\u0026counter]\n+        auto signal \u003d std::vector\u003c double \u003e( signal_size );\n+        std::generate( begin( signal ), end( signal ), [\u0026counter] {\n+            const auto t \u003d counter++ / signal_size;\n+            return 0.5 * std::sin( 80 * 2 * M_PI * t ) + std::sin( 50 * 2 * M_PI * t );\n+        } );\n+\n+        WHEN( \"fft is computed\" )\n         {\n-            const auto t \u003d counter++/signal_size;\n-            return 0.5*std::sin(80*2*M_PI*t) + std::sin(50*2*M_PI*t);\n-        });\n+            const auto result \u003d fft( signal );\n \n-        WHEN(\"fft is computed\")\n-        {\n-            const auto result \u003d fft(signal);\n-\n-            THEN(\"frequencies 50 and 80 have values of signal_size/2 resp. 0.5*signal_size/2\")\n+            THEN( \"frequencies 50 and 80 have values of signal_size/2 resp. 0.5*signal_size/2\" )\n             {\n-                CHECK(std::abs(result[50]) \u003d\u003d Approx(signal_size/2));\n-                CHECK(std::abs(result[80]) \u003d\u003d Approx(0.5*signal_size/2));\n+                CHECK( std::abs( result[ 50 ] ) \u003d\u003d Approx( signal_size / 2 ) );\n+                CHECK( std::abs( result[ 80 ] ) \u003d\u003d Approx( 0.5 * signal_size / 2 ) );\n             }\n \n-            THEN(\"all other frequencies are close to zero\")\n+            THEN( \"all other frequencies are close to zero\" )\n             {\n-                for(decltype(result)::size_type i\u003d0; i\u003cresult.size(); ++i)\n+                for ( decltype( result )::size_type i \u003d 0; i \u003c result.size(); ++i )\n                 {\n-                    if(i \u003d\u003d 50 || i \u003d\u003d 80)\n+                    if ( i \u003d\u003d 50 || i \u003d\u003d 80 )\n                         continue;\n-                    CHECK(std::abs(result[i]) \u003c 1e4*std::numeric_limits\u003cdouble\u003e::epsilon());\n+                    CHECK( std::abs( result[ i ] ) \u003c\n+                           1e4 * std::numeric_limits\u003c double \u003e::epsilon() );\n                 }\n             }\n         }\n \n-        WHEN(\"fft_abs_scaled is computed\")\n+        WHEN( \"fft_abs_scaled is computed\" )\n         {\n-            const auto result \u003d fft_abs_scaled(signal);\n+            const auto result \u003d fft_abs_scaled( signal );\n \n-            THEN(\"frequencies 50 and 80 have values of 1 resp. 0.5\")\n+            THEN( \"frequencies 50 and 80 have values of 1 resp. 0.5\" )\n             {\n-                CHECK(result[50] \u003d\u003d Approx(1));\n-                CHECK(result[80] \u003d\u003d Approx(0.5));\n+                CHECK( result[ 50 ] \u003d\u003d Approx( 1 ) );\n+                CHECK( result[ 80 ] \u003d\u003d Approx( 0.5 ) );\n             }\n \n-            THEN(\"all other frequencies are close to zero\")\n+            THEN( \"all other frequencies are close to zero\" )\n             {\n-                for(decltype(result)::size_type i\u003d0; i\u003cresult.size(); ++i)\n+                for ( decltype( result )::size_type i \u003d 0; i \u003c result.size(); ++i )\n                 {\n-                    if(i \u003d\u003d 50 || i \u003d\u003d 80)\n+                    if ( i \u003d\u003d 50 || i \u003d\u003d 80 )\n                         continue;\n-                    CHECK(result[i] \u003c 1e4*std::numeric_limits\u003cdouble\u003e::epsilon());\n+                    CHECK( result[ i ] \u003c 1e4 * std::numeric_limits\u003c double \u003e::epsilon() );\n                 }\n             }\n         }\n     }\n }\n \n-SCENARIO(\"complex sine waves of 50 and 80 Hz\", \"fft\")\n+SCENARIO( \"complex sine waves of 50 and 80 Hz\", \"fft\" )\n {\n     using namespace sequencer::audio;\n \n-    GIVEN(\"overlapping sine waves of 50 and 80 Hz\")\n+    GIVEN( \"overlapping sine waves of 50 and 80 Hz\" )\n     {\n         double counter \u003d 0;\n-        auto signal \u003d std::vector\u003cstd::complex\u003cdouble\u003e\u003e(signal_size);\n-        std::generate(begin(signal), end(signal), [\u0026counter]\n+        auto signal \u003d std::vector\u003c std::complex\u003c double \u003e \u003e( signal_size );\n+        std::generate( begin( signal ), end( signal ), [\u0026counter] {\n+            const auto t \u003d counter++ / signal_size;\n+            return std::complex{0.5 * std::sin( 80 * 2 * M_PI * t ) + std::sin( 50 * 2 * M_PI * t ),\n+                                0.0};\n+        } );\n+\n+        WHEN( \"radix2 fft is computed\" )\n         {\n-            const auto t \u003d counter++/signal_size;\n-            return std::complex{0.5*std::sin(80*2*M_PI*t) + std::sin(50*2*M_PI*t), 0.0};\n-        });\n+            const auto result \u003d radix2( signal );\n \n-        WHEN(\"radix2 fft is computed\")\n-        {\n-            const auto result \u003d radix2(signal);\n-\n-            THEN(\"frequencies 50 and 80 have values of signal_size/2 resp. 0.5*signal_size/2\")\n+            THEN( \"frequencies 50 and 80 have values of signal_size/2 resp. 0.5*signal_size/2\" )\n             {\n-                CHECK(std::abs(result[50]) \u003d\u003d Approx(signal_size/2));\n-                CHECK(std::abs(result[80]) \u003d\u003d Approx(0.5*signal_size/2));\n+                CHECK( std::abs( result[ 50 ] ) \u003d\u003d Approx( signal_size / 2 ) );\n+                CHECK( std::abs( result[ 80 ] ) \u003d\u003d Approx( 0.5 * signal_size / 2 ) );\n             }\n-            THEN(\"frequencies (signal_size-50) and (signal_size-80) have values of signal_size/2 resp. 0.5*signal_size/2\")\n+            THEN( \"frequencies (signal_size-50) and (signal_size-80) have values of signal_size/2 \"\n+                  \"resp. 0.5*signal_size/2\" )\n             {\n-                CHECK(std::abs(result[signal_size-50]) \u003d\u003d Approx(signal_size/2));\n-                CHECK(std::abs(result[signal_size-80]) \u003d\u003d Approx(0.5*signal_size/2));\n+                CHECK( std::abs( result[ signal_size - 50 ] ) \u003d\u003d Approx( signal_size / 2 ) );\n+                CHECK( std::abs( result[ signal_size - 80 ] ) \u003d\u003d Approx( 0.5 * signal_size / 2 ) );\n             }\n \n-            THEN(\"all other frequencies are close to zero\")\n+            THEN( \"all other frequencies are close to zero\" )\n             {\n-                for(decltype(result)::size_type i\u003d0; i\u003cresult.size(); ++i)\n+                for ( decltype( result )::size_type i \u003d 0; i \u003c result.size(); ++i )\n                 {\n-                    if(i \u003d\u003d 50 || i \u003d\u003d 80 || i \u003d\u003d signal_size-50 || i \u003d\u003d signal_size-80)\n+                    if ( i \u003d\u003d 50 || i \u003d\u003d 80 || i \u003d\u003d signal_size - 50 || i \u003d\u003d signal_size - 80 )\n                         continue;\n-                    CHECK(std::abs(result[i]) \u003c 1e4*std::numeric_limits\u003cdouble\u003e::epsilon());\n+                    CHECK( std::abs( result[ i ] ) \u003c\n+                           1e4 * std::numeric_limits\u003c double \u003e::epsilon() );\n                 }\n             }\n \n-            AND_WHEN(\"inverse radix2 fft is computed\")\n+            AND_WHEN( \"inverse radix2 fft is computed\" )\n             {\n-                const auto signal2 \u003d inverse_radix2(result);\n+                const auto signal2 \u003d inverse_radix2( result );\n \n-                THEN(\"computed signal coincides with input signal\")\n+                THEN( \"computed signal coincides with input signal\" )\n                 {\n-                    CHECK(std::equal(begin(signal), end(signal), begin(signal2), end(signal2),\n-                                     [](auto lhs, auto rhs){ return std::abs(lhs - rhs) \u003c 1e4*std::numeric_limits\u003cdouble\u003e::epsilon(); }));\n+                    CHECK( std::equal( begin( signal ), end( signal ), begin( signal2 ),\n+                                       end( signal2 ), []( auto lhs, auto rhs ) {\n+                                           return std::abs( lhs - rhs ) \u003c\n+                                                  1e4 * std::numeric_limits\u003c double \u003e::epsilon();\n+                                       } ) );\n                 }\n             }\n         }",
      "revId": "759688cb397518fbb1a1340e369a6a47c6d849c3",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}