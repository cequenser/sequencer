{
  "comments": [
    {
      "robotId": "clang-format",
      "robotRunId": "http://source.kaidimensional.de:8080/job/psv/job/clang-format/276/",
      "fixSuggestions": [],
      "key": {
        "uuid": "0e860c2c_c3634ce5",
        "filename": "tests/sequencer/midi/clock_test.cpp",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1016797
      },
      "writtenOn": "2019-08-10T10:05:36Z",
      "side": 1,
      "message": "underlying_clock_type testing_clock;\n         sequencer_clock_type sequencer_clock{testing_clock};\n \n-        GIVEN(\"a started midi clock\")\n+        GIVEN( \"a started midi clock\" )\n         {\n             auto controller_ready_promise \u003d std::make_shared\u003c std::promise\u003c void \u003e \u003e();\n             const auto controller_ready \u003d controller_ready_promise-\u003eget_future();\n \n             auto sender \u003d clock_counting_sender{};\n             auto midi_clock \u003d midi::clock{sequencer_clock, sender};\n-            const auto clock_done \u003d\n-                std::async( std::launch::async,\n-                            [\u0026midi_clock, controller_ready \u003d std::move( controller_ready_promise )] {\n-                                controller_ready-\u003eset_value();\n-                                midi_clock.run();\n-                            } );\n+            const auto clock_done \u003d std::async(\n+                std::launch::async,\n+                [\u0026midi_clock, controller_ready \u003d std::move( controller_ready_promise )] {\n+                    controller_ready-\u003eset_value();\n+                    midi_clock.run();\n+                } );\n             // make sure that midi_clock.shut_down() is called before the blocking destructor of\n             // clock_done is called\n             const auto midi_clock_raii_shutdown \u003d\n                 make_midi_clock_raii_shutdown( midi_clock, clock_done );\n             controller_ready.wait();\n \n-            WHEN(\"the clock is started and the sequencer clock sends time point 0\")\n+            WHEN( \"the clock is started and the sequencer clock sends time point 0\" )\n             {\n                 midi_clock.start();\n \n-                THEN(\"the clock sends 1 clock message\")\n-                {\n-                    std::unique_lock lock(sender.shared-\u003emessage_mutex);\n-                    sender.shared-\u003emessage_received.wait(lock, [\u0026sender]{ return sender.shared-\u003eclock_message_count \u003d\u003d 1; });\n-                    CHECK(sender.shared-\u003eclock_message_count \u003d\u003d 1);\n-                }\n-\n-                WHEN( \"the sequencer clock is increased 20 times by 10 ms\")\n-                {\n-                    THEN(\"the clock sends 10 clock messages\")\n+                THEN( \"the clock sends 1 clock message\" )\n+                {\n+                    std::unique_lock lock( sender.shared-\u003emessage_mutex );\n+                    sender.shared-\u003emessage_received.wait(\n+                        lock, [\u0026sender] { return sender.shared-\u003eclock_message_count \u003d\u003d 1; } );\n+                    CHECK( sender.shared-\u003eclock_message_count \u003d\u003d 1 );\n+                }\n+\n+                WHEN( \"the sequencer clock is increased 20 times by 10 ms\" )\n+                {\n+                    THEN( \"the clock sends 10 clock messages\" )\n                     {\n                         {\n-                            std::unique_lock lock(sender.shared-\u003emessage_mutex);\n-                            sender.shared-\u003emessage_received.wait(lock, [\u0026sender]{ return sender.shared-\u003eclock_message_count \u003d\u003d 1; });\n+                            std::unique_lock lock( sender.shared-\u003emessage_mutex );\n+                            sender.shared-\u003emessage_received.wait( lock, [\u0026sender] {\n+                                return sender.shared-\u003eclock_message_count \u003d\u003d 1;\n+                            } );\n                         }\n                         auto time \u003d testing_clock.now();\n-                        for(auto i\u003d0; i\u003c20; ++i)\n+                        for ( auto i \u003d 0; i \u003c 20; ++i )\n                         {\n                             time +\u003d 10ms;\n-                            testing_clock.set(time);\n-                            std::unique_lock lock(sender.shared-\u003emessage_mutex);\n-                            sender.shared-\u003emessage_received.wait(lock, [i,\u0026sender]\n+                            testing_clock.set( time );\n+                            std::unique_lock lock( sender.shared-\u003emessage_mutex );\n+                            sender.shared-\u003emessage_received.wait( lock, [i, \u0026sender] {\n+                                return sender.shared-\u003eclock_message_count \u003d\u003d\n+                                       1 + int( ( i + 1 ) / 2.083333 );\n+                            } );\n+                        }\n+\n+                        REQUIRE( sender.shared-\u003eclock_message_count \u003d\u003d 10 );\n+\n+                        WHEN( \"the tempo is changed to 60 bpm\" )\n+                        {\n+                            midi_clock.set_tempo( 60.0_bpm );\n+\n+                            REQUIRE( sender.shared-\u003eclock_message_count \u003d\u003d 10 );\n+                            const auto previously_sent_messages \u003d 10;\n+\n+                            WHEN( \"the sequencer clock is increased 20 times by 10 ms\" )\n                             {\n-                                return sender.shared-\u003eclock_message_count \u003d\u003d 1+int((i+1)/2.083333);\n-                            });\n-                        }\n-\n-                        REQUIRE(sender.shared-\u003eclock_message_count \u003d\u003d 10);\n-\n-                        WHEN(\"the tempo is changed to 60 bpm\")\n-                        {\n-                            midi_clock.set_tempo(60.0_bpm);\n-\n-                            REQUIRE(sender.shared-\u003eclock_message_count \u003d\u003d 10);\n-                            const auto previously_sent_messages \u003d 10;\n-\n-                            WHEN( \"the sequencer clock is increased 20 times by 10 ms\")\n-                            {\n-                                THEN(\"the clock sends 5 more clock messages\")\n+                                THEN( \"the clock sends 5 more clock messages\" )\n                                 {\n                                     auto time \u003d underlying_clock_type::time_point{200ms};\n-                                    for(auto i\u003d0; i\u003c20; ++i)\n+                                    for ( auto i \u003d 0; i \u003c 20; ++i )\n                                     {\n                                         time +\u003d 10ms;\n-                                        testing_clock.set(time);\n-                                        std::unique_lock lock(sender.shared-\u003emessage_mutex);\n-                                        // (i+1)*10ms + 2.5*10ms remaining from running clock at 120 bpm\n-                                        const auto new_messages \u003d ((i+1+2)*midi_clock.pulses_per_quarter_note() + midi_clock.pulses_per_quarter_note()/2)/100;\n-                                        const auto expected_messages \u003d previously_sent_messages + new_messages;\n-                                        sender.shared-\u003emessage_received.wait(lock, [\u0026sender,expected_messages]\n+                                        testing_clock.set( time );\n+                                        std::unique_lock lock( sender.shared-\u003emessage_mutex );\n+                                        // (i+1)*10ms + 2.5*10ms remaining from running clock at 120\n+                                        // bpm\n+                                        const auto new_messages \u003d\n+                                            ( ( i + 1 + 2 ) * midi_clock.pulses_per_quarter_note() +\n+                                              midi_clock.pulses_per_quarter_note() / 2 ) /\n+                                            100;\n+                                        const auto expected_messages \u003d\n+                                            previously_sent_messages + new_messages;\n+                                        sender.shared-\u003emessage_received.wait(\n+                                            lock, [\u0026sender, expected_messages] {\n+                                                return sender.shared-\u003eclock_message_count \u003d\u003d\n+                                                       expected_messages;\n+                                            } );\n+                                    }\n+\n+                                    REQUIRE( sender.shared-\u003eclock_message_count \u003d\u003d 15 );\n+\n+                                    WHEN( \"the tempo is changed to 30 bpm\" )\n+                                    {\n+                                        midi_clock.set_tempo( 30.0_bpm );\n+\n+                                        REQUIRE( sender.shared-\u003eclock_message_count \u003d\u003d 15 );\n+                                        const auto previously_sent_messages \u003d 15;\n+\n+                                        WHEN( \"the sequencer clock is increased 20 times by 10 ms\" )\n                                         {\n-                                            return sender.shared-\u003eclock_message_count \u003d\u003d expected_messages;\n-                                        });\n-                                    }\n-\n-                                    REQUIRE(sender.shared-\u003eclock_message_count \u003d\u003d 15);\n-\n-                                    WHEN(\"the tempo is changed to 30 bpm\")\n-                                    {\n-                                        midi_clock.set_tempo(30.0_bpm);\n-\n-                                        REQUIRE(sender.shared-\u003eclock_message_count \u003d\u003d 15);\n-                                        const auto previously_sent_messages \u003d 15;\n-\n-                                        WHEN( \"the sequencer clock is increased 20 times by 10 ms\")\n-                                        {\n-                                            THEN(\"the clock sends 5 more clock messages\")\n+                                            THEN( \"the clock sends 5 more clock messages\" )\n                                             {\n-                                                auto time \u003d underlying_clock_type::time_point{400ms};\n-                                                for(auto i\u003d0; i\u003c20; ++i)\n+                                                auto time \u003d\n+                                                    underlying_clock_type::time_point{400ms};\n+                                                for ( auto i \u003d 0; i \u003c 20; ++i )\n                                                 {\n                                                     time +\u003d 10ms;\n-                                                    testing_clock.set(time);\n+                                                    testing_clock.set( time );\n                                                     const auto now \u003d sequencer_clock.now();\n-                                                    using time_point \u003d std::remove_const_t\u003cdecltype(now)\u003e;\n-                                                    std::unique_lock lock(sender.shared-\u003emessage_mutex);\n-                                                    const auto expected_messages \u003d (i\u003c4) ? previously_sent_messages :\n-                                                                                           (i\u003c13) ? (previously_sent_messages+1) :\n-                                                                                                    (previously_sent_messages+2);\n-                                                    sender.shared-\u003emessage_received.wait(lock, [\u0026sender,expected_messages]\n-                                                    {\n-                                                        return sender.shared-\u003eclock_message_count \u003d\u003d expected_messages;\n-                                                    });\n+                                                    using time_point \u003d\n+                                                        std::remove_const_t\u003c decltype( now ) \u003e;\n+                                                    std::unique_lock lock(\n+                                                        sender.shared-\u003emessage_mutex );\n+                                                    const auto expected_messages \u003d\n+                                                        ( i \u003c 4 )\n+                                                            ? previously_sent_messages\n+                                                            : ( i \u003c 13 )\n+                                                                  ? ( previously_sent_messages + 1 )\n+                                                                  : ( previously_sent_messages +\n+                                                                      2 );\n+                                                    sender.shared-\u003emessage_received.wait(\n+                                                        lock, [\u0026sender, expected_messages] {\n+                                                            return sender.shared\n+                                                                       -\u003eclock_message_count \u003d\u003d\n+                                                                   expected_messages;\n+                                                        } );\n                                                 }\n \n-                                                REQUIRE(sender.shared-\u003eclock_message_count \u003d\u003d 17);\n+                                                REQUIRE( sender.shared-\u003eclock_message_count \u003d\u003d 17 );\n                                             }\n                                         }\n                                     }",
      "revId": "96facf210e0ebfcd8cf61e3d288b0f43ee50c805",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735",
      "unresolved": false
    }
  ]
}